# =============================================================================
# ECS Container Build, Push & Deploy
# Builds Docker images, pushes to AWS ECR, and deploys to ECS Fargate
# On pull requests: build only (no push, no deploy)
# On push to main/develop: build, push to ECR, deploy to ECS
# =============================================================================

name: ECS Build & Deploy

on:
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'VERSION'
      - '.github/workflows/ecs-build.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'VERSION'
      - '.github/workflows/ecs-build.yml'
  workflow_dispatch:
    inputs:
      push_to_ecr:
        description: 'Push images to ECR (even from PR)'
        required: false
        default: 'false'
        type: boolean
      deploy_to_ecs:
        description: 'Deploy to ECS after pushing images'
        required: false
        default: 'true'
        type: boolean
      environment:
        description: 'Target environment'
        required: false
        default: 'dev'
        type: choice
        options:
          - dev
          - prod

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-2' }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME || 'lab-visualizer' }}

# Permissions required for OIDC authentication with AWS
permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  # ===========================================================================
  # Determine what changed and read version
  # ===========================================================================
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Read version
        id: version
        run: echo "version=$(cat VERSION)" >> $GITHUB_OUTPUT

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'

      - name: Determine target environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

  # ===========================================================================
  # Build Backend Image
  # ===========================================================================
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.backend == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.PROJECT_NAME }}-backend
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=ref,event=pr,prefix=pr-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Configure AWS credentials
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHub-Actions-Build-Push-Container

      - name: Login to Amazon ECR
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true')
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true') }}
          build-args: |
            APP_VERSION=${{ needs.changes.outputs.app_version }}
            BUILD_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.event.pull_request.updated_at || '' }}
          tags: |
            ${{ steps.login-ecr.outputs.registry && format('{0}/{1}-{2}-backend:{3}', steps.login-ecr.outputs.registry, env.PROJECT_NAME, needs.changes.outputs.environment, steps.meta.outputs.version) || '' }}
            ${{ steps.login-ecr.outputs.registry && github.event_name == 'push' && format('{0}/{1}-{2}-backend:latest', steps.login-ecr.outputs.registry, env.PROJECT_NAME, needs.changes.outputs.environment) || '' }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Generate build summary
        run: |
          echo "## Backend Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ needs.changes.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Pushed | ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true') }} |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            echo "| Digest | \`${{ steps.build.outputs.digest }}\` |" >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # Build Frontend Image
  # ===========================================================================
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
      image_digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.PROJECT_NAME }}-frontend
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=ref,event=pr,prefix=pr-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Configure AWS credentials
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true')
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true')
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push frontend image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true') }}
          build-args: |
            APP_VERSION=${{ needs.changes.outputs.app_version }}
            BUILD_SHA=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.event.pull_request.updated_at || '' }}
          tags: |
            ${{ steps.login-ecr.outputs.registry && format('{0}/{1}-{2}-frontend:{3}', steps.login-ecr.outputs.registry, env.PROJECT_NAME, needs.changes.outputs.environment, steps.meta.outputs.version) || '' }}
            ${{ steps.login-ecr.outputs.registry && github.event_name == 'push' && format('{0}/{1}-{2}-frontend:latest', steps.login-ecr.outputs.registry, env.PROJECT_NAME, needs.changes.outputs.environment) || '' }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Generate build summary
        run: |
          echo "## Frontend Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${{ needs.changes.outputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Pushed | ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == 'true') }} |" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.build.outputs.digest }}" ]; then
            echo "| Digest | \`${{ steps.build.outputs.digest }}\` |" >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # Post build summary on PR
  # ===========================================================================
  pr-comment:
    name: PR Comment
    runs-on: ubuntu-latest
    needs: [build-backend, build-frontend]
    if: always() && github.event_name == 'pull_request'

    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const backendResult = '${{ needs.build-backend.result }}';
            const frontendResult = '${{ needs.build-frontend.result }}';
            const backendTag = '${{ needs.build-backend.outputs.image_tag }}' || 'N/A (no changes)';
            const frontendTag = '${{ needs.build-frontend.outputs.image_tag }}' || 'N/A (no changes)';

            const statusEmoji = (result) => {
              if (result === 'success') return 'âœ…';
              if (result === 'failure') return 'âŒ';
              if (result === 'skipped') return 'â­ï¸';
              return 'âš ï¸';
            };

            const body = `## ðŸ³ Docker Build Results

            | Image | Status | Tag |
            |-------|--------|-----|
            | Backend | ${statusEmoji(backendResult)} ${backendResult} | \`${backendTag}\` |
            | Frontend | ${statusEmoji(frontendResult)} ${frontendResult} | \`${frontendTag}\` |

            > **Note:** Images are pushed to the **dev** ECR on merge to \`develop\` and to the **prod** ECR on merge to \`main\`.
            > To push from this PR, use the workflow dispatch with \`push_to_ecr: true\`.
            `;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ðŸ³ Docker Build Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  # ===========================================================================
  # Deploy to ECS
  # Triggers force-new-deployment and waits for services to stabilize
  # ===========================================================================
  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: [changes, build-backend, build-frontend]
    # Run when images were pushed and at least one build succeeded
    if: |
      always() &&
      (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.push_to_ecr == true)) &&
      (github.event_name != 'workflow_dispatch' || inputs.deploy_to_ecs != false) &&
      (needs.build-backend.result == 'success' || needs.build-frontend.result == 'success')
    env:
      # TF_PROJECT_NAME must match the Terraform project_name variable used when deploying infrastructure.
      # The ECS cluster/service names are derived from this value.
      # Override via GitHub repository variable if your Terraform project_name differs.
      TF_PROJECT_NAME: ${{ vars.TF_PROJECT_NAME || 'aws-infra-visualizer' }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHub-Actions-ECS-Deploy

      - name: Set deployment targets
        id: targets
        run: |
          ENV="${{ needs.changes.outputs.environment }}"

          # Backend ECS resources
          echo "backend_cluster=${TF_PROJECT_NAME}-${ENV}-cluster" >> $GITHUB_OUTPUT
          echo "backend_service=${TF_PROJECT_NAME}-${ENV}-service" >> $GITHUB_OUTPUT

          # Frontend ECS resources (uses -fe suffix per Terraform convention)
          echo "frontend_cluster=${TF_PROJECT_NAME}-fe-${ENV}-cluster" >> $GITHUB_OUTPUT
          echo "frontend_service=${TF_PROJECT_NAME}-fe-${ENV}-service" >> $GITHUB_OUTPUT

          echo "## Deployment Targets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Cluster | Service Name |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|---------|--------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | \`${TF_PROJECT_NAME}-${ENV}-cluster\` | \`${TF_PROJECT_NAME}-${ENV}-service\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | \`${TF_PROJECT_NAME}-fe-${ENV}-cluster\` | \`${TF_PROJECT_NAME}-fe-${ENV}-service\` |" >> $GITHUB_STEP_SUMMARY

      - name: Deploy backend service
        if: needs.build-backend.result == 'success'
        run: |
          echo "Triggering force-new-deployment for backend..."
          aws ecs update-service \
            --cluster "${{ steps.targets.outputs.backend_cluster }}" \
            --service "${{ steps.targets.outputs.backend_service }}" \
            --force-new-deployment \
            --query 'service.deployments[0].{status:status,desired:desiredCount,running:runningCount}' \
            --output table

      - name: Deploy frontend service
        if: needs.build-frontend.result == 'success'
        run: |
          echo "Triggering force-new-deployment for frontend..."
          aws ecs update-service \
            --cluster "${{ steps.targets.outputs.frontend_cluster }}" \
            --service "${{ steps.targets.outputs.frontend_service }}" \
            --force-new-deployment \
            --query 'service.deployments[0].{status:status,desired:desiredCount,running:runningCount}' \
            --output table

      - name: Wait for backend deployment to stabilize
        if: needs.build-backend.result == 'success'
        timeout-minutes: 15
        run: |
          echo "Waiting for backend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster "${{ steps.targets.outputs.backend_cluster }}" \
            --services "${{ steps.targets.outputs.backend_service }}"
          echo "Backend deployment stable."

      - name: Wait for frontend deployment to stabilize
        if: needs.build-frontend.result == 'success'
        timeout-minutes: 15
        run: |
          echo "Waiting for frontend service to reach steady state..."
          aws ecs wait services-stable \
            --cluster "${{ steps.targets.outputs.frontend_cluster }}" \
            --services "${{ steps.targets.outputs.frontend_service }}"
          echo "Frontend deployment stable."

      - name: Generate deployment summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY

          BACKEND_STATUS="${{ needs.build-backend.result }}"
          FRONTEND_STATUS="${{ needs.build-frontend.result }}"

          if [ "$BACKEND_STATUS" = "success" ]; then
            echo "| Backend | Deployed |" >> $GITHUB_STEP_SUMMARY
          elif [ "$BACKEND_STATUS" = "skipped" ]; then
            echo "| Backend | Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Backend | Not deployed ($BACKEND_STATUS) |" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$FRONTEND_STATUS" = "success" ]; then
            echo "| Frontend | Deployed |" >> $GITHUB_STEP_SUMMARY
          elif [ "$FRONTEND_STATUS" = "skipped" ]; then
            echo "| Frontend | Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Frontend | Not deployed ($FRONTEND_STATUS) |" >> $GITHUB_STEP_SUMMARY
          fi
